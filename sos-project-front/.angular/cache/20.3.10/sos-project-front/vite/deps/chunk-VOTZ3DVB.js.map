{
  "version": 3,
  "sources": ["../../../../../../node_modules/@angular/cdk/fesm2022/scrolling2.mjs", "../../../../../../node_modules/@angular/cdk/fesm2022/platform.mjs"],
  "sourcesContent": ["/** The possible ways the browser may handle the horizontal scroll axis in RTL languages. */\r\nvar RtlScrollAxisType;\r\n(function (RtlScrollAxisType) {\r\n    /**\r\n     * scrollLeft is 0 when scrolled all the way left and (scrollWidth - clientWidth) when scrolled\r\n     * all the way right.\r\n     */\r\n    RtlScrollAxisType[RtlScrollAxisType[\"NORMAL\"] = 0] = \"NORMAL\";\r\n    /**\r\n     * scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\r\n     * all the way right.\r\n     */\r\n    RtlScrollAxisType[RtlScrollAxisType[\"NEGATED\"] = 1] = \"NEGATED\";\r\n    /**\r\n     * scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\r\n     * all the way right.\r\n     */\r\n    RtlScrollAxisType[RtlScrollAxisType[\"INVERTED\"] = 2] = \"INVERTED\";\r\n})(RtlScrollAxisType || (RtlScrollAxisType = {}));\r\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\r\nlet rtlScrollAxisType;\r\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\r\nlet scrollBehaviorSupported;\r\n/** Check whether the browser supports scroll behaviors. */\r\nfunction supportsScrollBehavior() {\r\n    if (scrollBehaviorSupported == null) {\r\n        // If we're not in the browser, it can't be supported. Also check for `Element`, because\r\n        // some projects stub out the global `document` during SSR which can throw us off.\r\n        if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\r\n            scrollBehaviorSupported = false;\r\n            return scrollBehaviorSupported;\r\n        }\r\n        // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\r\n        if (document.documentElement?.style && 'scrollBehavior' in document.documentElement.style) {\r\n            scrollBehaviorSupported = true;\r\n        }\r\n        else {\r\n            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\r\n            // supported but it doesn't handle scroll behavior, or it has been polyfilled.\r\n            const scrollToFunction = Element.prototype.scrollTo;\r\n            if (scrollToFunction) {\r\n                // We can detect if the function has been polyfilled by calling `toString` on it. Native\r\n                // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\r\n                // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\r\n                // polyfilled functions as supporting scroll behavior.\r\n                scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\r\n            }\r\n            else {\r\n                scrollBehaviorSupported = false;\r\n            }\r\n        }\r\n    }\r\n    return scrollBehaviorSupported;\r\n}\r\n/**\r\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\r\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\r\n */\r\nfunction getRtlScrollAxisType() {\r\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\r\n    if (typeof document !== 'object' || !document) {\r\n        return RtlScrollAxisType.NORMAL;\r\n    }\r\n    if (rtlScrollAxisType == null) {\r\n        // Create a 1px wide scrolling container and a 2px wide content element.\r\n        const scrollContainer = document.createElement('div');\r\n        const containerStyle = scrollContainer.style;\r\n        scrollContainer.dir = 'rtl';\r\n        containerStyle.width = '1px';\r\n        containerStyle.overflow = 'auto';\r\n        containerStyle.visibility = 'hidden';\r\n        containerStyle.pointerEvents = 'none';\r\n        containerStyle.position = 'absolute';\r\n        const content = document.createElement('div');\r\n        const contentStyle = content.style;\r\n        contentStyle.width = '2px';\r\n        contentStyle.height = '1px';\r\n        scrollContainer.appendChild(content);\r\n        document.body.appendChild(scrollContainer);\r\n        rtlScrollAxisType = RtlScrollAxisType.NORMAL;\r\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\r\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\r\n        // dealing with one of the other two types of browsers.\r\n        if (scrollContainer.scrollLeft === 0) {\r\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\r\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\r\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\r\n            // return 0 when we read it again.\r\n            scrollContainer.scrollLeft = 1;\r\n            rtlScrollAxisType =\r\n                scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;\r\n        }\r\n        scrollContainer.remove();\r\n    }\r\n    return rtlScrollAxisType;\r\n}\r\n\r\nexport { RtlScrollAxisType, getRtlScrollAxisType, supportsScrollBehavior };\r\n\r\n", "export { Platform } from './platform2.mjs';\nimport * as i0 from '@angular/core';\nimport { NgModule } from '@angular/core';\nexport { normalizePassiveListenerOptions, supportsPassiveEventListeners } from './passive-listeners.mjs';\nexport { RtlScrollAxisType, getRtlScrollAxisType, supportsScrollBehavior } from './scrolling2.mjs';\nexport { _getEventTarget, _getFocusedElementPierceShadowDom, _getShadowRoot, _supportsShadowDom } from './shadow-dom.mjs';\nexport { _isTestEnvironment } from './test-environment.mjs';\nimport '@angular/common';\nclass PlatformModule {\n  static ɵfac = function PlatformModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || PlatformModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PlatformModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PlatformModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\n\n/** Cached result Set of input types support by the current browser. */\nlet supportedInputTypes;\n/** Types of `<input>` that *might* be supported. */\nconst candidateInputTypes = [\n// `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n// first changing it to something else:\n// The specified value \"\" does not conform to the required format.\n// The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n'color', 'button', 'checkbox', 'date', 'datetime-local', 'email', 'file', 'hidden', 'image', 'month', 'number', 'password', 'radio', 'range', 'reset', 'search', 'submit', 'tel', 'text', 'time', 'url', 'week'];\n/** @returns The input types supported by this browser. */\nfunction getSupportedInputTypes() {\n  // Result is cached.\n  if (supportedInputTypes) {\n    return supportedInputTypes;\n  }\n  // We can't check if an input type is not supported until we're on the browser, so say that\n  // everything is supported when not on the browser. We don't use `Platform` here since it's\n  // just a helper function and can't inject it.\n  if (typeof document !== 'object' || !document) {\n    supportedInputTypes = new Set(candidateInputTypes);\n    return supportedInputTypes;\n  }\n  let featureTestInput = document.createElement('input');\n  supportedInputTypes = new Set(candidateInputTypes.filter(value => {\n    featureTestInput.setAttribute('type', value);\n    return featureTestInput.type === value;\n  }));\n  return supportedInputTypes;\n}\nexport { PlatformModule, getSupportedInputTypes };\n"],
  "mappings": ";;;;;;;;AACA,IAAI;AAAA,CACH,SAAUA,oBAAmB;AAK1B,EAAAA,mBAAkBA,mBAAkB,QAAQ,IAAI,CAAC,IAAI;AAKrD,EAAAA,mBAAkBA,mBAAkB,SAAS,IAAI,CAAC,IAAI;AAKtD,EAAAA,mBAAkBA,mBAAkB,UAAU,IAAI,CAAC,IAAI;AAC3D,GAAG,sBAAsB,oBAAoB,CAAC,EAAE;;;ACVhD,IAAM,iBAAN,MAAM,gBAAe;AAAA,EACnB,OAAO,OAAO,SAAS,uBAAuB,mBAAmB;AAC/D,WAAO,KAAK,qBAAqB,iBAAgB;AAAA,EACnD;AAAA,EACA,OAAO,OAAyB,iBAAiB;AAAA,IAC/C,MAAM;AAAA,EACR,CAAC;AAAA,EACD,OAAO,OAAyB,iBAAiB,CAAC,CAAC;AACrD;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,gBAAgB,CAAC;AAAA,IACvF,MAAM;AAAA,IACN,MAAM,CAAC,CAAC,CAAC;AAAA,EACX,CAAC,GAAG,MAAM,IAAI;AAChB,GAAG;AAGH,IAAI;AAEJ,IAAM,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA,EAK5B;AAAA,EAAS;AAAA,EAAU;AAAA,EAAY;AAAA,EAAQ;AAAA,EAAkB;AAAA,EAAS;AAAA,EAAQ;AAAA,EAAU;AAAA,EAAS;AAAA,EAAS;AAAA,EAAU;AAAA,EAAY;AAAA,EAAS;AAAA,EAAS;AAAA,EAAS;AAAA,EAAU;AAAA,EAAU;AAAA,EAAO;AAAA,EAAQ;AAAA,EAAQ;AAAA,EAAO;AAAM;AAE/M,SAAS,yBAAyB;AAEhC,MAAI,qBAAqB;AACvB,WAAO;AAAA,EACT;AAIA,MAAI,OAAO,aAAa,YAAY,CAAC,UAAU;AAC7C,0BAAsB,IAAI,IAAI,mBAAmB;AACjD,WAAO;AAAA,EACT;AACA,MAAI,mBAAmB,SAAS,cAAc,OAAO;AACrD,wBAAsB,IAAI,IAAI,oBAAoB,OAAO,WAAS;AAChE,qBAAiB,aAAa,QAAQ,KAAK;AAC3C,WAAO,iBAAiB,SAAS;AAAA,EACnC,CAAC,CAAC;AACF,SAAO;AACT;",
  "names": ["RtlScrollAxisType"]
}
